---
layout: homework
title: "Homework #1"
---

<style>
img {
    border: 1px solid #000;
}

.warning {
    background-color: yellow;
    color: #aa1122;
    font-weight: bold;
}

.hidden {
    display: none;
}

.hintButton {
    color: #7788ff;
    cursor: pointer;
}
</style>
<script>
document.addEventListener('DOMContentLoaded', hideHints);

function hideHints(evt) {
    document.querySelectorAll('.hint').forEach((ele, i) => {
        const div = document.createElement('div');
        div.id = 'hint' + i + 'Button';
        ele.id = 'hint' + i;
        ele.classList.add('hidden');
        div.addEventListener('click', onClick);
        div.textContent = 'Show Hint';
        div.className = 'hintButton';
        ele.parentNode.insertBefore(div, ele);
    });

}

function onClick(evt) {
    const hintId = this.id.replace('Button', '');
    const hint = document.getElementById(hintId);
    hint.classList.toggle('hidden');
    this.textContent = this.textConent === 'Show Hint' ? 'Hide Hint' : 'Show Hint';
}
</script>

# Assignment #1 - Bits and Snakes - Due Thursday, Sep 14th at 11pm

## Overview

1. __Part 1__: `BitList` Class
2. __Part 2__: A Little _Bit_ of Decoding

## Preparation 

1. Submit your GitHub username in the 1st class survey
2. Clone the repository

## Part 1: `BitList` Class

In a file called `bits.py`, create a class, `BitList`, that represents a series of bits. The class and instances of the class will have methods representing operations that can be performed on those bits.

### The `BitList` class should support the following behavior:



#### `BitList(s)`

Create a new series of bits from a string that represents a binary number:

* the string must start with `0b`
* the remainder of the string should only consist of 0's and 1's
* if the string entered in the format above, `raise` a `ValueError`
* if the string entered is valid, find some way to retain the bits 
	* ave the data entered on `self`
	* choose a data type for the value that will best serve you

Example Usage:

```
b = BitList('0b10000011')
```

```
try:
    b = BitList('10000011')
except ValueError:
    print('Format is invalid; does not start with 0b')
# Format is invalid; does not start with 0b
```

```
try:
    b = BitList('0bFE02)
except ValueError:
    print('Format is invalid; does not consist of only 0 and 1')
# Format is invalid; does not consist of only 0 and 1
```
<hr>

#### `BitList.from_ints(b1, b2, ...bN)`

A new series of bits can also be created by supplying integers directly to a `@staticmethod` `from_ints`:

* `raise` a value error there are digits other than 0 and 1
* notice that `from_ints` is called from the class itself (rather than an instance); it's a static method, so decorate with `@staticmethod`

```
b = BitList.from_ints(1, 1, 0, 0, 0, 0, 0, 1)
print(type(b)) # <class 'bits.BitList'>
print(b) # 11000001
```

Calling `from_ints` returns a new `BitList`.


<hr>

#### `printing`

Implement the appropriate method on the `BitList` class such that printing out a `BitList` instance displays every bit in the series of bits:

* the prefix `0b` is not shown
* there are no spaces between each bit

```
b = BitList('0b10000011')
print(b) # 10000011
```

<hr>

#### `.arithmetic_shift_left()` and `.arithmetic_shift_right()`


The bits in the series can be shifted to the left or right by one.

1. for shift left
	* the left most bit should be discarded
	* a zero should be added to the right
	* `0110` &rarr; `1100`
2. for shift right
	* the right most bit should be discarded
	* the left most bit should be duplicated
	* `1100` &rarr; `1110`

This method __has no parameters__ and __it does not return a value__.

Note that the internal representation of bits should change as shown below:

```
b = BitList('0b10000010')
b.arithmetic_shift_right()
print(b) # 11000001
```

<hr>



#### `==`

If both `BitList` instances contain the same series of bits, then they're equal:

```
b1 = BitList('0b11000001')
b2 = BitList.from_ints(1, 1, 0, 0, 0, 0, 0, 1)
print(b1 == b2) # True!
```

<hr>

#### `.bitwise_and(otherBitList)`

A bitwise and can be performed with an _incoming_ `BitList`:

```
b1 = BitList('0b10000011')
b2 = BitList('0b11000001')
b3 = b1.bitwise_and(b2)
print(b3) #1 0000001
```

<hr>

#### `.decode(encoding)`

The bits can be decoded as 7-bit ASCII (`us-ascii`):


```
bits = BitList.from_ints(1, 1, 0, 0, 0, 0, 1)
ch = bits.decode('us-ascii')
print(ch) # a
```

This should work if there are multiple characters encoded:

```
new_bit_list = BitList('0b11000011000001')
s = new_bit_list.decode('us-ascii')
print(s) # aA
```

If you're looking for a challenge, you could add support for decoding `utf-8`:


```
b = BitList('0b11110000100111111001100010000010111000101000001010101100')
s = b.decode('utf-8')
print(s) # ðŸ˜‚â‚¬

```


### Details

## Part 2: A Little _Bit_ of Decoding

Write an interactive program that:

1. asks the user for a series of 0's and 1's: `Give me some bits!` 
	* if the input does not consist only of 0, 1 and / or space, ask again
	* if there are spaces in the input, they can be removed	
	* 01110000 01100011 can be treated as 0111000001100011 
2. if you implemented both `utf-8` and `us-ascii` in part 1, ask for an encoding: `Give me an encoding!`
3. based on the input, display the following:
	* the original input without spaces: `Input: 0111000001100011`
	* the code points, as bits, represented by the series of bits, based on the encoding (default to `us-ascii` if you did not ask for an encoding as detailed in the previous requirement)
	* so, if the original input was `011100011000111111001`
	* ... and the encoding was  `us-ascii` (which is a 7-bit encoding)
	* ... show the 7 bit groupings: `011100011000111111001` 
	* âš ï¸ this is much trickier with `utf-8` as breaking the input into equal groups isn't adequate; `utf-8` is variable width, so it can be 1, 2, 3 or 4 bytes (8, 16, 24 or 32 bit groups)


```
Give me some bits!
> 11110000 10011111 10010000 10001101 11100010 10000010 10101100
Give me an encoding!
> utf-8
Input: 11110000100111111001000010001101111000101000001010101100
Code Points Binary: 000011111010000001101 0010000010101100
Code Points Decimal: 128013 8364
Decoded String: ðŸâ‚¬
Type Y to enter more bits?
> Y
====================


Give me some bits!
> 1000001
Give me an encoding!
> us-ascii
Input: 1000001
Code Points Binary: 1000001
Code Points Decimal: 65
Decoded String: A
> Type Y to enter more bits?
Y
====================


Give me some bits!
> 11110000 10011111 10010000 10001101 11100010 10000010 10101100
Give me an encoding!
> utf-8
you already entered those bits and encoding: ðŸâ‚¬
Type Y to enter more bits?
> nope
====================


Thanks, these were all the bits you entered!
utf-8-11110000100111111001000010001101111000101000001010101100 >>> ðŸâ‚¬
us-ascii-1000001 >>> A
```
