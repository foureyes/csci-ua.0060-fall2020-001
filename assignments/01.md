---
layout: homework
title: "Homework #1"
---

<style>
img {
    border: 1px solid #000;
}

.warning {
    background-color: yellow;
    color: #aa1122;
    font-weight: bold;
}

.hidden {
    display: none;
}

.hintButton {
    color: #7788ff;
    cursor: pointer;
}
</style>
<script>
document.addEventListener('DOMContentLoaded', hideHints);

function hideHints(evt) {
    document.querySelectorAll('.hint').forEach((ele, i) => {
        const div = document.createElement('div');
        div.id = 'hint' + i + 'Button';
        ele.id = 'hint' + i;
        ele.classList.add('hidden');
        div.addEventListener('click', onClick);
        div.textContent = 'Show Hint';
        div.className = 'hintButton';
        ele.parentNode.insertBefore(div, ele);
    });

}

function onClick(evt) {
    const hintId = this.id.replace('Button', '');
    const hint = document.getElementById(hintId);
    hint.classList.toggle('hidden');
    this.textContent = this.textConent === 'Show Hint' ? 'Hide Hint' : 'Show Hint';
}
</script>

# Assignment #1 - Bits and Snakes - Due Thursday, Sep 14th at 11pm

## Overview

1. __Part 1__: `BitList` Class
2. __Part 2__: A Little _Bit_ of Decoding

## Preparation 

1. Submit your GitHub username in the 1st class survey
2. Clone the repository

## Part 1: `BitList` Class

In a file called `bits.py`, create a class, `BitList`, that represents a series of bits. The class and instances of the class will have methods representing operations that can be performed on those bits.

### The `BitList` class should support the following behavior:



#### `BitList(s)`

Create a new series of bits from a string that represents a binary number:

* the string must start with `0b`
* the remainder of the string should only consist of 0's and 1's
* if the string entered in the format above, `raise` a `ValueError`
* if the string entered is valid, find some way to retain the bits 
	* ave the data entered on `self`
	* choose a data type for the value that will best serve you

Example Usage:

```
b = BitList('0b10000011')
```

```
try:
    b = BitList('10000011')
except ValueError:
    print('Format is invalid; does not start with 0b')
# Format is invalid; does not start with 0b
```

```
try:
    b = BitList('0bFE02)
except ValueError:
    print('Format is invalid; does not consist of only 0 and 1')
# Format is invalid; does not consist of only 0 and 1
```
<hr>

#### `BitList.from_ints(b1, b2, ...bN)`

A new series of bits can also be created by supplying integers directly to a `@staticmethod` `from_ints`:

* `raise` a value error there are digits other than 0 and 1
* notice that `from_ints` is called from the class itself (rather than an instance); it's a static method, so decorate with `@staticmethod`

```
b = BitList.from_ints(1, 1, 0, 0, 0, 0, 0, 1)
print(type(b)) # <class 'bits.BitList'>
print(b) # 11000001
```

Calling `from_ints` returns a new `BitList`.


<hr>

#### `printing`

Implement the appropriate method on the `BitList` class such that printing out a `BitList` instance displays every bit in the series of bits:

* the prefix `0b` is not shown
* there are no spaces between each bit

```
b = BitList('0b10000011')
print(b) # 10000011
```

<hr>

#### `.arithmetic_shift_left()` and `.arithmetic_shift_right()`

This method __has no parameters__ and __it does not return a value__.

The bits in the series can be shifted to the left or right by one.

1. for shift left
	* the left most bit should be discarded
	* a zero should be added to the right
	* `0110` &rarr; `1100`
2. for shift right
	* the right most bit should be discarded
	* the left most bit should be duplicated
	* `1100` &rarr; `1110`

Note that the internal representation of bits should change. That is, there is no return value; instead, the actual `BitList` instance changes:

```
b = BitList('0b10000010')
b.arithmetic_shift_right()
print(b) # 11000001
```

<hr>



#### `==`

If both `BitList` instances contain the same series of bits, then they're equal:

```
b1 = BitList('0b11000001')
b2 = BitList.from_ints(1, 1, 0, 0, 0, 0, 0, 1)
print(b1 == b2) # True!
```

<hr>

#### `.bitwise_and(otherBitList)`


This method has __one parameter, another instance of `BitList`__, and it returns a new `BitList` instance.

A bitwise and can be performed with an _incoming_ `BitList`:

* a bitwise and can only be performed if both sequences of bits are of equal length
* for every position, use a logical `and` to produce a new bit
	* treat `1` as `True`
	* treat `0` as `False`
	* use these boolean values with a logical `and` evaluate to either `True` or `False`
	* consequently, performing a bitwise and on `1110` and `1011` produces `1010`
		```
1110 (TTTF) - Operand 1
1011 (TFTT) - Operand 2
1010 (TFTF) - Result
```
	* optionally, simply multiplying each position also works!
* again, the method itself has one parameter, the other `BitList` instance
* it returns a new `BitList` instance

```
b1 = BitList('0b10000011')
b2 = BitList('0b11000001')
b3 = b1.bitwise_and(b2)
print(b3) #1 0000001
```

<hr>

#### `.decode(encoding)`

This method has a __single parameter__, the encoding (a `str`), and it __returns a string__:

1. the encoding can only be `us-ascii` or `utf-8` (see optional section on `utf-8` below)
2. it returns a string 

An instance of `BitList` can be decoded. In the example below, the bits are treated as 7-bit ASCII (`us-ascii`):

```
bits = BitList.from_ints(1, 1, 0, 0, 0, 0, 1)
ch = bits.decode('us-ascii')
print(ch) # a
```

This should work if there are multiple characters encoded:

```
new_bit_list = BitList('0b11000011000001')
s = new_bit_list.decode('us-ascii')
print(s) # aA
```

One way to implement this is to:

1. calculate the decimal value from the bits
2. convert the decimal value into a character with `chr`

__Optional__ If you're looking for a challenge, you could add support for decoding `utf-8`.

This is a little tricky, as chunking bits into equivalent lengths isn't adequate:

* `utf-8` is variable length
* the "leading byte" must be examined to determine how many bytes total are required
* for example, encountering the byte `11101010` means that there should be three bytes total (there are 3 1's)
* the continuation bits are all prefixed with `10`
* see the slides / notebook on `unicode` for more details

```
b = BitList('0b11110000100111111001100010000010111000101000001010101100')
s = b.decode('utf-8')
print(s) # 😂€

```

## Part 2: A Little _Bit_ of Decoding

Write an interactive program that:

1. asks the user for a series of 0's and 1's: `Give me some bits!` 
	* if the input does not consist only of 0, 1 and / or space, ask again
	* if there are spaces in the input, they can be removed	
	* 01110000 01100011 can be treated as 0111000001100011 
2. ask for an encoding: `Give me an encoding!`
	* if you only implemened `us-ascii` in part 1...
	* this question should still be asked, but assume that the user will enter `us-ascii`
3. if the user had entered the bits and encoding previously, skip to step 6 where the user is asked if they'd like to continue
4. based on the input, display the following:
	1. the original input without spaces: `Input: 0111000001100011`
	2. the code points, in binary: `Code Points Binary: 0111000 1100011 1111001` 
		* based on the encoding (default to `us-ascii` if you did not ask for an encoding as detailed in the previous requirement)... group the bits
		* if the original input was `011100011000111111001` and the encoding was `us-ascii` (which is a 7-bit encoding)
		* then simply show groups of 7 bits: `0111000 1100011 1111001` 
		* ⚠️ this is much trickier with `utf-8` 
			* breaking the input into equal groups isn't adequate
			* `utf-8` is variable width, so it can be 1, 2, 3 or 4 bytes (8, 16, 24 or 32 bit groups)
		* no input validation is needed to determine if the correct number of bits were entered for the encoding specified
	3. the code points, in decimal: `Code Points Decimal: 128013 8364`
		* you'll have to find some way to convert the bits entered into decimal values
	4. the decoded string: `Decoded String: 🐍€`
5. find some way to "save" all of the bits, encodings, and corresponding decoded string
6. ask the user if they'd like to continue `Type Y to enter more bits?`
	* if they answer with a `Y`, then start at step 1 again
7. if a user does not continue, show all bits entered, encodings and their related decoded string
	```
Thanks, these were all the bits you entered!
utf-8-11110000100111111001000010001101111000101000001010101100 >>> 🐍€
us-ascii-1000001 >>> A
```

Example Run:

```
Give me some bits!
> 11110000 10011111 10010000 10001101 11100010 10000010 10101100
Give me an encoding!
> utf-8
Input: 11110000100111111001000010001101111000101000001010101100
Code Points Binary: 000011111010000001101 0010000010101100
Code Points Decimal: 128013 8364
Decoded String: 🐍€
Type Y to enter more bits?
> Y
====================


Give me some bits!
> 1000001
Give me an encoding!
> us-ascii
Input: 1000001
Code Points Binary: 1000001
Code Points Decimal: 65
Decoded String: A
> Type Y to enter more bits?
Y
====================


Give me some bits!
> 11110000 10011111 10010000 10001101 11100010 10000010 10101100
Give me an encoding!
> utf-8
you already entered those bits and encoding: 🐍€
Type Y to enter more bits?
> nope
====================


Thanks, these were all the bits you entered!
utf-8-11110000100111111001000010001101111000101000001010101100 >>> 🐍€
us-ascii-1000001 >>> A
```
